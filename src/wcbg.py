import sys, os
sys.path.append('/usr/lib/pyshared/python2.6')
import gv
import xml.etree.ElementTree as et
from pygraph.classes.digraph import digraph
from pygraph.readwrite.dot import *
from mcs import *
from mincs import *

# Kernel objects
kernelObjects = [
	"process_call", "process", "load_dll", "load_image", "open_file", "open_key", "get_file_attributes", 
	"create_directory", "set_file_attributes", "set_file_time", "create_file", "create_mutex", "query_value", 
	"set_value" "check_for_debugger", "get_system_directory", "create_thread", "create_window", "find_window", 
	"enum_window", "show_window", "destroy_window", "set_windows_hook", "stored_created_file", "vm_protect", 
	"connection", "ping", "find_file"
	]

# Gets pid from a list of attributes
def getPidFromAttr (nodeAttr):
	for k, v in nodeAttr:
		if k == "pid":
			return v
	return -1

# Gets process node with given pid
def getProcNodeWithPid (g, nodeList, pid):
	for node in nodeList:
		nodeAttr = g.node_attributes (node)
		nodePid = getPidFromAttr (nodeAttr)
		if nodePid == pid:
			return node
	return None

# Gets parent node of a process
def getProcParent (g, node):
	if len (g) == 0:
		print 'In getproc(): Empty graph'
		return None
	nodeList = g.__iter__()
	nodeAttr = node.attrib.items ()
	if nodeAttr == []:
		print 'In getproc(): Empty attribute list'
		return None
		
	pid = getPidFromAttr (nodeAttr)
	if pid == -1:
		print 'In getproc(): No attribute for pid was not found'
		return None
		
	node = getProcNodeWithPid (g, nodeList, pid)
	return node

# Add nodes in the KOBG
def addNodes (g, root):
	global nodeid
	parent = nodeid
	if len (g) == 0:
		nodeAttr = [("nodename", root.tag)] + root.attrib.items ()
		g.add_node (nodeid, nodeAttr)
	
	for child in root:
		if child.tag in kernelObjects:
			if child.tag == "process":
				parent = getProcParent (g, child)
			
			if parent == None:
				print 'In addnodes(): Parent node cannot be None'
				sys.exit (0)
			
			attr = [("nodename", child.tag)] + child.attrib.items ()
			nodeid = nodeid + 1
			g.add_node (nodeid, attr)
			g.add_edge ((parent, nodeid))
		addNodes (g, child)

# Initializes KOBG construction
def makeKOBJGraph (filename):
	if os.path.isfile (filename):
		pass
	else:
		raise IOError ('File does not exists')
	tree = et.parse (filename)
	root = tree.getroot ()
	g = digraph ()
	addNodes (g, root)
	return g

# Display graphs
#def display (g):
#	l = g.nodes ()
#	e = g.edges ()
#	print l
#	print e

# Returns a set of KOBGs
def makeGraphSet (malwareDir):
	graphSet = []
	global nodeid
	nodeid = 1
	for filename in os.listdir (malwareDir):
		filename = malwareDir + "/" + filename
		g = makeKOBJGraph (filename)
		nodeid = nodeid + 1
		graphSet.append (g)
	return graphSet

# Normalize edge weights
def normalize_weight (g, n):
	for edge in g.edges ():
		wt = float (g.edge_weight (edge))
		g.set_edge_weight (edge, wt/n)
	return g

# Returns similarity index between two graphs
def similarity (wcbg, gnew):
	wcbg_edges = wcbg.edges ()
	gnew_edges = gnew.edges ()
	
	sum = 0
	for e1 in wcbg_edges:
		for e2 in gnew_edges:
			w_node1, w_node2 = e1
			g_node1, g_node2 = e2
			w_node1_attr = wcbg.node_attributes (w_node1)
			w_node2_attr = wcbg.node_attributes (w_node2)
			w_node1_label = w_node1_attr [0][1]
			w_node2_label = w_node2_attr [0][1]
			g_node1_attr = gnew.node_attributes (g_node1)
			g_node2_attr = gnew.node_attributes (g_node2)
			g_node1_label = g_node1_attr [0][1]
			g_node2_label = g_node2_attr [0][1]
			if g_node1_label == w_node1_label and g_node2_label == w_node2_label:
				sum = sum + gnew.edge_weight (e2)
				break
	
	sum = float (sum)
	n = min (len (gnew), len (wcbg))
	if n > 0:
		return sum/n
	else:
		return -1

# Checks if a graph is the subset of other graph
def issubset (hotpath, malware_kobg):
	mcs = mcsinit (hotpath, malware_kobg)
#	print mcs
#	print hotpath
	if len (mcs.nodes ()) == len (hotpath.nodes ()) and len (mcs.edges ()) == len (hotpath.edges ()):
		return True
	else:
		return False

# Final check if malware is of the same family
def isMalware (wcbg, hotpath, malware_kobg, gamma):
	similarity_index = similarity (wcbg, malware_kobg)
	print similarity_index
	issubset (hotpath, malware_kobg)
	if similarity_index > gamma and issubset (hotpath, malware_kobg):
		return True
	else:
		return False

# Initializes operations on guest malware`
def listen (hotpath):
	malware = sys.argv [2]
	malware_kobg = makeKOBJGraph (malware)
	print isMalware (wcbg, hotpath, malware_kobg, 0.3)

# Main function
if __name__ == '__main__':
	malwareDir = sys.argv[1]
	if os.path.isdir (malwareDir):
		pass
	else:
		raise IOError ('Directory does not exists')
	
	if os.listdir (malwareDir) == []:
		print 'In main: Directory specified is empty'
		sys.exit(0)
	
	gSet = makeGraphSet (malwareDir)
	if not gSet:
		print 'In main: Graph set is empty'
		sys.exit (0)

	index = 0
	length = len (gSet)
	print length
	g = gSet [0]
	while index < length:
		g, hotpath = mincs (g, gSet[index])
		index = index + 1

	setweight (g, hotpath)
	wcbg = normalize_weight (g, length)
	for node in wcbg:
		print wcbg.node_attributes (node)[0][1],
	print
	wbcg_save = write ()
	copy = digraph ()
	copy.add_graph (wcbg)
	dot = write (copy, False)
	gvv = gv.readstring (dot)
	gv.layout (gvv, 'dot')
	gv.render (gvv, 'png', 'wcbg.png')
	prunegraph (g, 0.5)
	listen (hotpath)


