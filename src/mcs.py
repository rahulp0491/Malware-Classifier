import sys, os
import xml.etree.ElementTree as et
from pygraph.classes.digraph import digraph

#state -> list containing used nodes of g1 and g2

# Gets the next unused pair of nodes in the state
def nextPair (g1, g2, state):
	if len (state [1][0]) == 0 or len (state [1][1]) == 0:
		return None
	g1_unused = state [1][0]
	g2_unused = state [1][1]
	node1 = g1_unused.pop(0)
	node2 = g2_unused.pop(0)
	g1_used = state [0][0]
	g2_used = state [0][1]
	g1_used.append (node1)
	g2_used.append (node2)
	return (node1, node2)

# Checks if the pair of nodes are legal/feasible
def isFeasiblePair (g1, g2, state, node1, node2):
	g1_unused = state [1][0]
	g2_unused = state [1][1]
	if not (node1 not in g1_unused and node2 not in g2_unused):
		return False
	
	g1_used = state [0][0]
	g2_used = state [0][1]
	if not (node1 in g1_used and node2 in g2_used):
		return False
			
	if not (g1.has_node (node1) and g2.has_node (node2)):
		return False
	
	g1_used.remove (node1)
	g2_used.remove (node2)

	if g1_used == [] or g2_used == []:
		g1_used.append (node1)
		g2_used.append (node2)
		return True
	
	length = len (g1_used)
	i = 0
	
	node1_attr = g1.node_attributes (node1)
	node2_attr = g2.node_attributes (node2)
	node1_label = node1_attr [0][1]
	node2_label = node2_attr [0][1]	
	
	if node1_label != node2_label:
		return False	
	
	while i < length:
		if (g1.has_edge ((g1_used [i], node1)) ^ g2.has_edge ((g2_used [i], node2))) or (g1.has_edge ((node1, g1_used [i])) ^  g2.has_edge ((node2, g2_used [i]))):
			return False
		i = i + 1
	
	g1_used.append (node1)
	g2_used.append (node2)
	return True

# Adds the pair of nodes to the subgraph in the state
def addPair (g1, g2, state, node1, node2):
	subGraph = state [2]
	if subGraph == None:
		subGraph = digraph ()
		subGraph.add_node (node1)
		state [2] = subGraph
		print 1
		return 
	
	subGraph.add_node (node1)
	g1_used = state [0][0]
	for node in g1_used:
		if node == node1:
			continue
		if g1.has_edge ((node, node1)):
			subGraph.add_edge ((node, node1))
		elif g1.has_edge ((node1, node)):
			subGraph.add_edge ((node1, node))

# McGregor's algorithm to find the maximum common subgraph of two graphs
def maxCS (g1, g2, state):
	nodePairs = nexPair (g1, g2, state)
	while nodePairs != None:
		g1_node, g2_node = nodePairs
		if isFeasiblePair (g1, g2, state, g1_node, g2_node):
			new_state = addPair (g1, g2, state, g1_node, g2_node)
		
