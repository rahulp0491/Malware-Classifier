import sys, os
import xml.etree.ElementTree as et
from pygraph.classes.digraph import digraph

# state -> list containing used nodes of g1 and g2

GTable = []
currentSize = 0
savedmcs = []

# Gets the next unused pair of nodes in the state
#def nextPair (g1, g2, state):
#	if len (state [1]) == 0:
#		return None
#	g_unused = state [1]
#	g_used = state [0]
#	
#	g1_usedlist = [node1 for node1, node2 in g_used]
#	g2_usedlist = [node2 for node1, node2 in g_used]
#	
#	for g1_node, g2_node in g_unused:
#		if g1_node not in g1_usedlist and g2_node not in g2_usedlist:
#			g_unused.remove ((g1_node, g2_node))		
#			g_used.append ((g1_node, g2_node))
#			return ((g1_node, g2_node))
#			break
#	return None

# Checks if the pair of nodes are legal/feasible
def isFeasiblePair (g1, g2, state, node1, node2):
	g_unused = state [1]
	if not ((node1, node2) in g_unused):
		return False
	
	g_used = state [0]
	if (node1, node2) in g_used:
		return False	
			
	if not (g1.has_node (node1) and g2.has_node (node2)):
		return False
	

	if g_used == []:
		return True
	
	length = len (g_used)
	
	node1_attr = g1.node_attributes (node1)
	node2_attr = g2.node_attributes (node2)
	node1_label = ' ' #node1_attr [0][1]
	node2_label = ' ' #node2_attr [0][1]	
	
	if node1_label != node2_label:
		return False	
	
	i = 0
	while i < length:
		if (node1, node2) != g_used [i]:
			if (g1.has_edge ((g_used [i][0], node1)) ^ g2.has_edge ((g_used [i][1], node2))) or (g1.has_edge ((node1, g_used [i][0])) ^  g2.has_edge ((node2, g_used [i][1]))):
				return False
		i = i + 1
	
	return True

# Adds the pair of nodes to the subgraph in the state
def addPair (g1, g2, state, node1, node2):
	g_subGraph = state [2]
	if g_subGraph == None:
		g1_subGraph = digraph ()
		g2_subGraph = digraph ()
		g1_subGraph.add_node (node1)
		g2_subGraph.add_node (node2)
		state [2] = (g1_subGraph, g2_subGraph)
		state [0].append ((node1, node2))
		return state
	
	g1_subGraph, g2_subGraph = g_subGraph
	g1_subGraph.add_node (node1)
	g2_subGraph.add_node (node2)
	g_used = state [0]
	for g1_node, g2_node in g_used:
		if g1.has_edge ((g1_node, node1)) and g2.has_edge ((g2_node, node2)):
			g_subGraph_wt = g1.edge_weight ((g1_node, node1)) + g2.edge_weight ((g2_node, node2))
			g1_subGraph.add_edge ((g1_node, node1), g_subGraph_wt)
			g2_subGraph.add_edge ((g2_node, node2), g_subGraph_wt)
		elif g1.has_edge ((node1, g1_node)) and g2.has_edge ((node2, g2_node)):
			g_subGraph_wt = g1.edge_weight ((node1, g1_node)) + g2.edge_weight ((node2, g2_node))
			g1_subGraph.add_edge ((node1, g1_node), g_subGraph_wt)
			g2_subGraph.add_edge ((node2, g2_node), g_subGraph_wt)
	
	state [0].append ((node1, node2))
	return state

def isLeaf (g1, g2, state):
	g_used = state [0]
	g1_usedlist = [node1 for node1, node2 in g_used]
	g2_usedlist = [node2 for node1, node2 in g_used]
	g1_iter = g1.__iter__ ()
	g2_iter = g2.__iter__ ()
	
	for g1_node in g1_iter:
		if g1_node not in g1_usedlist:
			return False
	
	for g2_node in g2_iter:
		if g2_node not in g2_usedlist:
			return False
	
	return True

def pruningCondition (g1, g2, state):
	g1_len = len (g1)
	g2_len = len (g2)
	
	global currentSize
	subGraph_len = len (state [2][0])
	states_left = min (g1_len, g2_len) - len (state [0])
	if currentSize >= subGraph_len + states_left:
		return True

def init_GTable (g1, g2):
	g1_iter = [node for node in g1.__iter__ ()]
	g2_iter = [node for node in g2.__iter__ ()]
	
	for g1_node in g1_iter:
		for g2_node in g2_iter:
			GTable.append ((g1_node, g2_node))

def update (state):
	if state [1] == None:
		state [1] = GTable [:]
		return
	
	g_unused = state [1][:]
	g_used = state [0]
	g1_usedlist = [g1_node for g1_node, g2_node in g_used]
	g2_usedlist = [g2_node for g1_node, g2_node in g_used]

	for g1_node, g2_node in g_unused:
		if g1_node in g1_usedlist or g2_node in g2_usedlist:
			state [1].remove ((g1_node, g2_node))

def savestate (state):
	copyof_used = state [0][:]
	copyof_unused = state [1][:]
	if state [2] == None:
		return [copyof_used, copyof_unused, None]
	g1_subgraph = state [2][0]
	g2_subgraph = state [2][1]
	g1_subgraph_nodes = g1_subgraph.nodes ()
	g2_subgraph_nodes = g2_subgraph.nodes ()
	g1_subgraph_edges = g1_subgraph.edges ()
	g2_subgraph_edges = g2_subgraph.edges ()
	g1_copy = digraph ()
	g2_copy = digraph ()
	g1_copy.add_nodes (g1_subgraph_nodes)
	g2_copy.add_nodes (g2_subgraph_nodes)
	
	for edge in g1_subgraph_edges:
		g1_copy.add_edge (edge, g1_subgraph.edge_weight (edge))
	
	for edge in g2_subgraph_edges:
		g2_copy.add_edge (edge, g2_subgraph.edge_weight (edge))
	
	copy = [copyof_used, copyof_unused, (g1_copy, g2_copy)]
	return copy

# McGregor's algorithm to find the maximum common subgraph of two graphs
def maxCS (g1, g2, state):
	update (state)
	global currentSize
	g_state = state
	for nodePair in g_state [1]:
		g1_node, g2_node = nodePair
# Code for testing-------------------------------------------------------
#		print g1_node, g2_node
#		if g_state [2] != None:
#			for node in g_state [2][0].nodes ():
#				print node,
#			print "|",
#			for node in g_state [2][1].nodes ():
#				print node,
#		print isFeasiblePair (g1, g2, g_state, g1_node, g2_node)
#------------------------------------------------------------------------
		if isFeasiblePair (g1, g2, g_state, g1_node, g2_node):
			g_copy = savestate (g_state)
			new_state = addPair (g1, g2, g_copy, g1_node, g2_node)
			if len (new_state [2][0]) > currentSize:
				currentSize = len (new_state [2][0])
				savedmcs.append (new_state [2])
			if not isLeaf (g1, g2, new_state) and not pruningCondition (g1, g2, new_state):
				maxCS (g1, g2, new_state)
	

def mcsinit (g1, g2):
	state = [[], None, None]
	init_GTable (g1, g2)
	maxCS (g1, g2, state)
	g1_subgraph, g2_subgraph = savedmcs.pop()
	print "Subgraph of G1: ",
	for node in g1_subgraph.nodes ():
		print node,
	print
	for edge in g1_subgraph.edges ():
		print edge,
	print
	for edge in g1_subgraph.edges ():
		print g1_subgraph.edge_weight (edge),
	print
	print "Subgraph of G2: ",
	for node in g2_subgraph.nodes ():
		print node,
	print
	for edge in g2_subgraph.edges ():
		print edge,
	print
	for edge in g2_subgraph.edges ():
		print g2_subgraph.edge_weight (edge),
	print
	print "Size:", currentSize
