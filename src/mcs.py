import sys, os
import xml.etree.ElementTree as et
from pygraph.classes.digraph import digraph

# state -> list containing used nodes of g1 and g2

# Gets the next unused pair of nodes in the state
def nextPair (g1, g2, state):
	if len (state [0]) == 0:
		return None
	g_unused = state [1]
	g_used = state [0]
	
	g1_usedlist = [node1 for node1, node2 in g_used]
	g2_usedlist = [node2 for node1, node2 in g_used]
	
	for g1_node, g2_node in g_unused:
		if g1_node not in g1_usedlist and g2_node not in g2_usedlist:
			g_unused.remove ((g1_node, g2_node))		
			g_used.append ((g1_node, g2_node))
			return ((g1_node, g2_node))
			break
	return None

# Checks if the pair of nodes are legal/feasible
def isFeasiblePair (g1, g2, state, node1, node2):
	g_unused = state [1]
	if not ((node1, node2) not in g_unused):
		return False
	
	g_used = state [0]
	if not ((node1, node2) in g_used):
		return False
			
	if not (g1.has_node (node1) and g2.has_node (node2)):
		return False
	

	if g_used == []:
		return True
	
	length = len (g_used)
	
	node1_attr = g1.node_attributes (node1)
	node2_attr = g2.node_attributes (node2)
	node1_label = ' ' #node1_attr [0][1]
	node2_label = ' ' #node2_attr [0][1]	
	
	if node1_label != node2_label:
		return False	
	
	i = 0
	while i < length:
		if (node1, node2) != g_used [i]:
			if (g1.has_edge ((g_used [i][0], node1)) ^ g2.has_edge ((g_used [i][1], node2))) or (g1.has_edge ((node1, g_used [i][0])) ^  g2.has_edge ((node2, g_used [i][1]))):
				return False
		i = i + 1
	
	return True

# Adds the pair of nodes to the subgraph in the state
def addPair (g1, g2, state, node1, node2):
	g_subGraph = state [2]
	if g_subGraph == None:
		g1_subGraph = digraph ()
		g2_subGraph = digraph ()
		g1_subGraph.add_node (node1)
		g2_subGraph.add_node (node2)
		state [2] = (g1_subGraph, g2_subGraph)
		return 
	
	g1_subGraph, g2_subGraph = g_subGraph
	g1_subGraph.add_node (node1)
	g2_subGraph.add_node (node2)
	g_used = state [0]
	for g1_node, g2_node in g_used:
		if g1_node == node1 and g2_node == node2:
			continue
		if g1.has_edge ((g1_node, node1)) and g2.has_edge ((g2_node, node2)):
			g1_subGraph.add_edge ((g1_node, node1))
			g2_subGraph.add_edge ((g2_node, node2))
		elif g1.has_edge ((node1, g2_node)):
			g1_subGraph.add_edge ((node1, g1_node))
			g2_subGraph.add_edge ((node2, g2_node))


def isLeaf (g1, g2, state):
	g_used = state [0]
	g1_usedlist = [node1 for node1, node2 in g_used]
	g2_usedlist = [node2 for node1, node2 in g_used]
	g1_iter = g1.__iter__ ()
	g2_iter = g2.__iter__ ()
	
	for g1_node in g1_iter:
		if g1_node not in g1_usedlist:
			return False
	
	for g2_node in g2_iter:
		if g2_node not in g2_usedlist:
			return False
	
	return True

# McGregor's algorithm to find the maximum common subgraph of two graphs
#def maxCS (g1, g2, state):
#	nodePairs = nextPair (g1, g2, state)
#	while nodePairs != None:
#		g1_node, g2_node = nodePairs
#		if isFeasiblePair (g1, g2, state, g1_node, g2_node):
#			new_state = addPair (g1, g2, state, g1_node, g2_node) [:]
			
			
			
		
