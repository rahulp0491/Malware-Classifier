import sys, os
import xml.etree.ElementTree as et
from pygraph.classes.digraph import digraph


#s[0] -> vertex list of g1
#s[1] -> vertex list of g2
#s[2] -> isomorphic subgraph till that state
#s[3] -> unused nodes

def size (s):
	s1 = s[2]
	return len(s1)

def isFeasiblePair (g1, g2, s, n1, n2):
	s1 = s[0]
	s2 = s[1]
	v1 = s1.pop()
	v2 = s2.pop()
	while s[0] and s[1]:
		nodeAttr1 = g1.node_attributes (v1)
		nodeAttr2 = g2.node_attributes (v2)
		vLabel1 = nodeAttr1 [0][1]
		vLabel2 = nodeAttr2 [0][1]
		if not (((g1.has_edge (v1, n1) and g2.has_edge (v2, n2)) or (g1.has_edge (n1, v1) and g2.has_edge (n2, v2)) or (not (g1.has_edge (v1, n1) or g2.has_edge (v2, n2))) or (not (g1.has_edge (n1, v1) or g2.has_edge (n2, v2)))) and (vLabel1 == vLabel2)):
			v1 = s[0].pop()
			v2 = s[1].pop()
			return -1
	return 1

def addPair (g1, g2, s, n1, n2):
	subG = s[2]
	s1 = s[0]
	s2 = s[1]
	if len (subG) == 0: 
		subG = digraph ()
	v1 = s1.pop()
	v2 = s2.pop()
	while s1 != [] and s2 != []:
		if (g1.has_edge (v1, n1) and g2.has_edge (v2, n2)):
			subG.add_node (v1, n1)
			
		elif (g1.has_edge (n1, v1) and g2.has_edge (n2, v2)):
			subG.add_node (n1, v1)
		
		v1 = s1.pop()
		v2 = s2.pop()
		s[0].append (v1)
		s[1].append (v2)
	
	s[2] = subG
	return s

def setUsed (g1, g2):
	g1Iter = g1.__iter__()
	g2Iter = g2.__iter__()
	unusedG = []
	for node1 in g1Iter:
		unusedG.append (node1)
	for node2 in g2Iter:
		unusedG.append (node2)
	
	return unusedG

def getv1v2FromUnused (g1, g2, unusedG):
	
	for v in unusedG:
		if g1.has_node (v):
			v1 = v
			flag1 = True
			break
		flag1 = False
	
	for v in unusedG:
		if g2.has_node (v):
			v2 = v
			flag2 = True
			break
		flag2 = False
	
	for v in unusedG:
		print v,
	
	if flag1 and flag2:
		return (v1, v2)
		
	return None

def mcs (g1, g2, s):
#	if len (s[3][0]) == 0 and len (s[3][1]) == 0: add this when mcs is called first
#		s[3] = setUsed (g1, g2)
	
	unusedG = s[3]
	for n in unusedG:
		print n,
	v = getv1v2FromUnused (g1, g2, unusedG)
	for n in unusedG:
		print n,
	global savedStates
	global currentSize
	while v != None:
		v1 = unusedG.remove (v[0])
		v2 = unusedG.remove (v[1])
		if isFeasiblePair (g1, g2, s, v1, v2) == 1:
			sNew = addPair (g1, g2, s, v1, v2)
			sNew [3] = unusedG
			if size (sNew) > currentSize:
				savedStates.append (sNew)
				currentSize = size (sNew)
			if len (unusedG) != 0 and (len(unusedG)/2) >= currentSize:
				mcs (g1, g2, sNew)
			
		v = getv1v2FromUnused (g1, g2, unusedG)

def initMCS (g1, g2):
	global savedStates
	global currentSize
	savedStates = []
	currentSize = 0
	unusedG = setUsed (g1, g2)
	v1 = []
	v2 = []
	subG = digraph ()
	s = [v1, v2, subG, unusedG]
	mcs (g1, g2, s)
